# **#14888 ì—°ì‚°ì ë¼ì›Œë„£ê¸°**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a37bcd7f-d524-4d26-b044-ad230cd1df40/Untitled.png)

### **ë¬¸ì œ ì •ë¦¬**

ìˆ˜ ë°°ì—´, ì—°ì‚°ì ë°°ì—´ì´ ì£¼ì–´ì§.
 ìˆ˜ì˜ ìˆœì„œëŠ” ë°”ê¿€ ìˆ˜ ì—†ê³ , ì—°ì‚°ì ë°°ì—´ì„ ë°”ê¿”ì„œ ìˆ˜í–‰í•œ ê²°ê³¼ì˜ ìµœëŒ“ê°’, ìµœì†Ÿê°’ì„ ì¶œë ¥! ì‹ì˜ ê³„ì‚°ì€ ì—°ì‚°ì ìš°ì„ ìˆœìœ„ ë¬´ì‹œí•˜ê³ , ì•ì—ì„œë¶€í„° ì§„í–‰í•´ì•¼ í•¨. ë‚˜ëˆ—ì…ˆì€ ëª«ë§Œ. ìŒìˆ˜/ì–‘ìˆ˜ = -(ì–‘ìˆ˜/ì–‘ìˆ˜)

### **ìƒê°í•´ë³´ê¸°**

ì—°ì‚°ìê°€ [0, 0, 1, 0] ì´ëŸ° ì‹ìœ¼ë¡œ ë“¤ì–´ì˜¨ë‹¤.
 ì—°ì‚°ì ë°°ì—´ ìˆœì„œì˜ ê²½ìš°ì˜ ìˆ˜ - ìˆœì—´ì¸ë°, ê°™ì€ ê²Œ ì¤‘ë³µë  ìˆ˜ ìˆìŒ. ê°™ì€ ê²ƒì„ í¬í•¨í•œ ìˆœì—´ ,,?

ì—°ì‚°ì ìš°ì„ ìˆœìœ„ë¥¼ ë¬´ì‹œí•œë‹¤ â€”> ê·¸ëƒ¥ ì•ì—ì„œë¶€í„° ë³€ìˆ˜ì— ê°’ì„ ì €ì¥í•´ë†”ë„ ëœë‹¤ ?

### **ì½”ë“œ ì“°ê¸°**

ìˆœì—´ ..ã…‹ã…‹ ì–´ë–»ê°œ í•˜ëŠ”ê±´ëŒ€. ë‚˜ëŠ” forë¬¸ ì¤‘ì²©ë°–ì— ë– ì˜¤ë¥´ì§€ ì•Šì•˜ê³ ..
 ê·¸ë¦¬ê³  ê·¸ê²Œ ë‹µì´ ì•„ë‹ˆë¼ëŠ” ì§ê°ë„ ìˆì–´ì„œ.. ê²€ìƒ‰í–ˆìŠµë‹ˆë‹¤.

```swift
func permuteWirth<T>(_ a: [T], _ n: Int) {
    if n == 0 {
        print(a)   // display the current permutation
    } else {
        var a = a
        permuteWirth(a, n - 1)
        for i in 0..<n {
            a.swapAt(i, n)
            permuteWirth(a, n - 1)
            a.swapAt(i, n)
        }
    }
}
```

ì˜¤ì˜¤...(o.o)b ì—¬ëŸ¬ê°€ì§€ ìˆœì—´ ì•Œê³ ë¦¬ì¦˜ì´ ìˆì—ˆì§€ë§Œ ì„ ì • ê¸°ì¤€ì€

1. ì½”í…Œë•Œ ì™¸ì›Œì„œ ì¨ì•¼ í•˜ëŠ”ë°... ì™¸ìš¸ ë§Œ í•œê°€? â€”> O ã…‹ã…‹
2. ìë£Œí˜• ìƒê´€ ì—†ëŠ”ê°€? â€”> O ã…‹ã…‹ ì¶œì²˜ëŠ” [ì—¬ê¸°](https://github.com/raywenderlich/swift-algorithm-club/tree/master/Combinatorics) ì…ë‹ˆë‹¤..

### **ë‚´ í’€ì´**

```swift
let numCount = Int(readLine()!)!
let nums = readLine()!.split(separator: " ").map{Int(String($0))!}
let oprs = readLine()!.split(separator: " ").map{Int(String($0))!}

var max = Int.min
var min = Int.max
```

ìš°ì„  ì…ë ¥ ì£¼ëŠ”ëŒ€ë¡œ ë°›ê³ , ìµœëŒ€ ìµœì†Œ ë¹„êµë¥¼ ìœ„í•œ max, min ê°’ë“¤ë„ ë§Œë“¤ì–´ ì¤¬ìŠµë‹ˆë‹¤.

```swift
var op: [Int] = []
for o in 0..<oprs.count {
    if oprs[o] == 0 { continue }
    for _ in 1...oprs[o] {
        op.append(o)
    }
}
```

ê·¸ë¦¬ê³  í•œ ë°°ì—´ì„ ë§Œë“¤ì—ˆëŠ”ë°ìš”... ì—°ì‚°ìê°€ [2, 1, 1, 1] ì´ë”´ ì‹ìœ¼ë¡œ ì˜¤ëŠ”ë° ì´ê²Œ ì¸ë±ìŠ¤ì— ë”°ë¼ 0: +, 1: -, 2: *, 3: / ì´ê±°ì–ì•„ìš”?? ê·¼ë° [2, 1, 1, 1] ì´ê±¸ ê·¸ëŒ€ë¡œ ì“°ë ¤ë‹ˆê¹Œ ë„ˆë¬´ ëŒ€ê°ˆ ì•„íŒŒì„œ ì´ê±¸
 [0, 0, 1, 2, 3] ìœ¼ë¡œ ë°”ê¿”ì£¼ëŠ” ì‘ì—…ì„ í–ˆìŠµë‹ˆë‹¤. (opë¼ëŠ” ë°°ì—´ì— ì €ì¥)

ê·¸ë¦¬ê³  ì´ê±¸ **ìˆœì—´ì„ ëŒë¦¬ê³ **, **ì¤‘ë³µì„ ì œê±°**í•œ í›„(ì‹œê°„ì´ˆê³¼ ë°©ì§€ìš©)
 **ì—°ì‚° ì‘ì—…ì„ í•˜ë‚˜í•˜ë‚˜ ìˆ˜í–‰**í•´ì„œ ê·¸ë•Œê·¸ë•Œ **ìµœëŒ€, ìµœì†Œë¥¼ ë¹„êµ**í•˜ë©´ ë˜ê² ë‹¤ ì‹¶ì—ˆì£  ~!!!

```swift
var pm: [[Int]] = []
func permuteWirth(_ a: [Int], _ n: Int) {
    if n == 0 {
        pm.append(a)
    } else {
        var a = a
        permuteWirth(a, n - 1)
        for i in 0..<n {
            a.swapAt(i, n)
            permuteWirth(a, n - 1)
            a.swapAt(i, n)
        }
    }
}
// ìˆœì—´ ë§Œë“¤ê¸°
permuteWirth(op, op.count-1)
```

ìœ„ì— ë³´ì´ëŠ” ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ìˆœì—´ì„ ëŒë ¸ìŠµë‹ˆë‹¤. ë°°ì—´ pmì€ ìˆœì—´ì„ ì €ì¥í•˜ëŠ” ë°°ì—´ì´ì—¬ìš”...ğŸ¤­
 ê·¼ë° ìš°ë¦¬ì˜ op( [0, 0, 1, 2, 3] )ì€ ì¤‘ë³µ ì›ì†Œê°€ ìˆì–ì•„ìš”? Setìœ¼ë¡œ ìºìŠ¤íŒ…í•´ì„œ ì¤‘ë³µì„ ì—†ì• ì¤¬ìŠµë‹ˆë‹¤.
 [0, 0, 1, 2, 3] ê³¼ [1, 0, 0, 2, 3] ê³¼ì˜ ìˆœì„œë„ ì¤‘ìš”í•˜ì§€ ì•Šìœ¼ë‹ˆê¹Œ ë‹¤ì‹œ Arrayë¡œë„ ì•ˆ ë°”ê¿”ì¤¬ì–´ìš”.

```swift
for ops in Set(pm) {
    
    var nums = nums
    var result = nums.removeFirst() // ì²˜ìŒ ìˆ«ì ë¯¸ë¦¬ ëŒ€ì…
    
    for op in ops {
        switch op {
        case 0: // ë”í•˜ê¸°
            result += nums.removeFirst()
        case 1: // ë¹¼ê¸°
            result -= nums.removeFirst()
        case 2: // ê³±í•˜ê¸°
            result *= nums.removeFirst()
        case 3: // ë‚˜ëˆ„ê¸°
            result /= nums.removeFirst()
        default:
            break
        }
    }
    
    // ìµœëŒ€, ìµœì†Œ ì ê²€
    if result > max {
        max = result
    }
    if result < min {
        min = result
    }
}
```

ìš°ë¦¬ì—ê²ŒëŠ” ë‘ ê°œì˜ Collectionì´ ìˆëŠ”ë°,
 í•˜ë‚˜ëŠ” numsê³  (ì²˜ìŒì— ì…ë ¥ë°›ì€) ë‹¤ë¥¸ í•˜ë‚˜ëŠ” ë°©ê¸ˆ ë§Œë“  pm Setì…ë‹ˆë‹¤.

pm ì€ [ 0, 0, 1, 2, 3 ], [ 0, 1, 0, 2, 3 ], ... ë­ ì´ëŸ° ì• ë“¤ë¡œ êµ¬ì„±ë˜ì–´ ìˆê³ 

[0, 0, 1, 2, 3] í•˜ë‚˜ë¥¼ ops, ê·¸ ì•ˆì˜ ì›ì†Œ í•˜ë‚˜ë¥¼ opë¼ê³  í–ˆì–´ìš”.

ê·¸ë¦¬ê³  ê·¸ opë¥¼ 0 â†’ 0 â†’ 1 â†’ 2 â†’ 3 ì´ë ‡ê²Œ í•˜ë‚˜í•˜ë‚˜ switchë¬¸ìœ¼ë¡œ ê²€ì‚¬í•©ë‹ˆë‹¤.

opì— ë”°ë¼ ê²°ê³¼ê°’ì— ë°”ë¡œ numsì˜ ì²« ë²ˆì§¸ ì›ì†Œë¥¼ ì—°ì‚°í•´ì£¼ê³ , ë™ì‹œì— ì§€ì›Œì¤ë‹ˆë‹¤.
 (ê·¸ë˜ì•¼ ë‹¤ìŒ ë²ˆ ì—°ì‚°í•  ìˆ«ìë¡œë„ ì²«ë²ˆì§¸ ì›ì†Œë¥¼ ì“¸ ìˆ˜ ìˆìœ¼ë‹ˆê¹Œìš”!)

ê·¸ë¦¬ê³  í•œ ops ( [0, 0, 1, 2, 3] )ì— ëŒ€í•œ ì—°ì‚°ì„ ëëƒˆìœ¼ë©´ ìµœì¢… ì—°ì‚° ê²°ê³¼ê°’ì´ í•˜ë‚˜ ë‚˜ì˜¤ê² ì£ ! ê·¸ê±¸ ë°”ë¡œ max, minì´ë‘ ë¹„êµí•´ì„œ max, minì— í•´ë‹¹ë˜ë©´ ì €ì¥í•´ì¤ë‹ˆë‹¤.

```swift
print(max)
print(min)
```

ì¶œë ¥í•˜ë©´ ë..~~

### **í’€ê³  ë‚˜ì„œ ì•Œê²Œëœ ê²ƒ**

ìˆœì—´ ì €ê±° ì–´ì¼€ ì™¸ìš°ë‚˜ ì‹¶ê³ ìš” ã…‹.. ë‹¤ í’€ê³  ë‚˜ì„œ ì‹œê°„ì´ ì§„ì§œ ì–´ë§ˆë¬´ì‹œí•˜ê²Œ ì˜¤ë˜ ê±¸ë ¤ì„œ ë‹¤ë¥¸ ì‚¬ëŒ í’€ì´ë¥¼ ë‘˜ëŸ¬ë´¤ëŠ”ë° ë‹¤ë“¤ dfsë¡œ í‘¸ì…¨ë”ë¼ê³ ìš” ..?? ì§„ì .. ì € dfs ì˜ ëª¨ë¥´ê±°ë“ ìš”.. ì•„ì°¨ ì‹¶ì—ˆì£ ..

```swift
let n = Int(readLine()!)!
let arr = readLine()!.split(separator: " ").map{Int(String($0))!}
let oper = readLine()!.split(separator: " ").map{Int(String($0))!}  //+,-,x,/

var maxN = -1000000000
var minN = 1000000000

func dfs(_ idx: Int, _ plus: Int, _ sub: Int, _ mul: Int, _ div: Int, _ tot: Int){
    if idx == n {
        maxN = max(maxN,tot)
        minN = min(minN,tot)
        return
    }

    if plus < oper[0]{
        dfs(idx+1, plus+1, sub,mul,div,tot+arr[idx])
    }
    if sub < oper[1]{
        dfs(idx+1, plus, sub+1,mul,div,tot-arr[idx])
    }
    if mul < oper[2]{
        dfs(idx+1, plus, sub,mul+1,div,tot*arr[idx])
    }
    if div < oper[3]{
        dfs(idx+1, plus, sub,mul,div+1,tot/arr[idx])
    }
}

dfs(1,0,0,0,0,arr[0])
print(maxN)
print(minN)
```

ê°œì©ŒëŠ” ì½”ë“œì¸ê±´ ì•Œê² ëŠ”ë° ë°”ë¡œ ì´í•´ê°€ ì•ˆê°€ì„œ ;; í•˜ë‚˜í•˜ë‚˜ ë”°ë¼ê°€ë³´ê³  ì˜¤ê² ìŠµë‹ˆë‹¤ ..
 ë‚˜ì¤‘ì— ë°±íŠ¸ë˜í‚¹ìœ¼ë¡œ ë‹¤ì‹œ í’€ë˜ìš”..........................ê°œíŒì¹˜ë„¤.
